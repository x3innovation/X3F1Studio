<!--
Use to create nested menus inside of `f1-menu` elements.

    <f1-menu selected="0">
    
      <f1-submenu icon="settings" label="Topics">
        <core-item label="Topic 1"></core-item>
        <core-item label="Topic 2"></core-item>
      </f1-submenu>
      
      <f1-submenu icon="settings" label="Favorites">
        <core-item label="Favorite 1"></core-item>
        <core-item label="Favorite 2"></core-item>
        <core-item label="Favorite 3"></core-item>
      </f1-submenu>
      
    </f1-menu>
    
There is a margin set on the submenu to indent the items.
You can override the margin by doing:

    f1-submenu::shadow #submenu {
      margin-left: 20px;
    }

@group Polymer Core Elements
@element f1-submenu
@extends core-item
-->

<link rel="import" href="../f1-menu/f1-menu.html">
<link rel="import" href="./f1-collapse.html">
<link rel="import" href="./f1-item.html">

<polymer-element name="f1-submenu" attributes="selected selectedItem label data icon">
    <template>

        <link rel="stylesheet" href="f1-submenu.css">

        <f1-item label="{{label}}" icon="{{icon}}" data="{{data}}" class="{{ {'core-selected' : active} | tokenList}}" on-tap="{{loadItems}}">
            <content select=".item-content"></content>
        </f1-item>

        <f1-menu id="submenu" selected="{{selected}}" selectedItem="{{selectedItem}}">
            <content></content>
        </f1-menu>

        <f1-collapse target="{{$.submenu}}" opened="{{opened}}" maxHeight="200px"></f1-collapse>

    </template>
    <script>

        Polymer('f1-submenu', {
            publish: {
                active: {value: false, reflect: true}
            },
            loading: false,
            opened: false,
//            get items() {
//                console.log("get items()");
//                console.log(this.$.submenu.items);
//                return this.$.submenu.items;
//            },
//            hasItems: function() {
//                return !!this.items.length;
//            },
            unselectAllItems: function() {
                this.$.submenu.selected = null;
                this.$.submenu.clearSelection();
            },
//            activeChanged1: function() {
//                console.log("activeChanged:" + this.active);
//                if (this.hasItems()) {
//                    this.opened = this.active;
//                }
//                if (!this.active) {
//                    this.unselectAllItems();
//                }
//            },
            toggle: function() {
                this.opened = !this.opened;
            },
            loadItems: function() {
                this.toggle();

                if (this.loading == true) {
                    return;
                }

                if (this.opened == false) {
                    return;
                }

                this.$.submenu.innerHTML = '';
                var p = document.createElement("p");
                p.innerHTML = 'loading...';
                this.$.submenu.appendChild(p);

                var recvCount = 0;
                var dmxFiles = [];
                var f1Submenu = this;
                var addToDropdownCallback = function() {
                    f1Submenu.$.submenu.innerHTML = '';
                    for (var i = 0; i < dmxFiles.length; i++) {
                        var f1Item = document.createElement("f1-item");
                        f1Item.label = dmxFiles[i].split("=")[1];
                        f1Item.data = dmxFiles[i].split("=")[0];
                        f1Submenu.$.submenu.appendChild(f1Item);
                    }
                    f1Submenu.unselectAllItems();
                    f1Submenu.loading = false;
                };

                var getFilesCallback = function(resp, totalCount) {
                    recvCount++;

                    dmxFiles.push(resp.id + "=" + resp.title);

                    console.log("show some progress bar: " + (recvCount / totalCount) * 100 + "%");

                    if (recvCount == totalCount) {
                        addToDropdownCallback();
                    }
                };
                this.loading = true;

                dog.getFiles(ball.projectFolder.id, [ball.DMXE_MIMETYPE, ball.DMX_MIMETYPE], getFilesCallback);
            },
//            activate: function() {
//                console.log("activate");
//                if (this.active) {
//                    console.log(this.$.submenu.items);
//                    this.toggle();
//                    this.unselectAllItems();
//                }
//            },
            selectedItemChanged: function() {
                console.log("selectedItemChanged");
                if (this.selectedItem != null) {
                    this.label = this.selectedItem.label;
                    this.opened = false;
                }
            },
        });
    </script>
</polymer-element>
